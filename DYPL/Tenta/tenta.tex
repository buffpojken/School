\documentclass[a4paper,10pt]{article}

\usepackage[latin1]{inputenc}
% \usepackage[swedish]{babel}
\usepackage[english]{babel}

\usepackage{xspace,graphicx}
\usepackage{url}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{textcomp}
\usepackage{amssymb}

% The three lines below gives paragraphs with a distance between
% instead of indented first line.
\frenchspacing
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus .5ex minus .5ex}

\title{Test - DYPL}
\author{Daniel Sundstrom \\ 
  \texttt{daniel@sykewarrior.com}\\\\
  \texttt{I believe in rough consensus and running code.}}
  
\date{\today}

\begin{document}
\maketitle
%\tableofcontents

\section{Question 1}
%What are the major differences in terms of design philosophy between Ruby and Python? Are there any similarities? In what ways are these design philosophies visible in the languages? Give examples, discuss, explain them and motivate your choices.
There are some major differences in the philosophy underpinning the design and the choices made for each language. In short, these differences can be described as; \emph{Multiple inheritance vs. Mixins}, \emph{Blocks vs. Functions} and \emph{Built-in Functions vs. Global Object}. These differences will be explored in depth below.

\subsection{Multiple inheritance vs. Mixins}
One of the major differences in design between Ruby and Python is how the language handles class-based behavior modification, both at runtime and at write time. Ruby favors a module-based approach, where specific methods\footnote{Which, in Ruby, of course includes attributes since they are implemented as methods} are grouped together in named modules, which in turn are included in the desired classes to provide the behavior. Modules can be included both as class methods and as instance methods, depending on the keyword used for inclusion. This is illustrated in the example below. 
\lstinputlisting{modules.rb}
As the example shows, this allows for composing the aggregate behavior for a class into separate, re-usable components (since a module can be included in any number of classes). Python, on the other hand, supports the same behavior through a limited form of multiple inheritance\footnote{Resolution is depth-first, left-to-right} as shown below: 
\lstinputlisting{inheritance.py}
As clearly shown in the examples above, both of these styles support the same effect - but point to interesting differences in design philosophy. 
One of the basic tenets of OOP\footnote{Object-Oriented Programming} is its suitability and ability to map and represent real-world systems and relationships, and this is also one of basic foundation of object-oriented modeling as taught and discussed today\cite{good_ideas}\cite{real_world_modelling}. The relationship of RangedNinja in regard to Ninja is more of superset-subset rather than a formal relationship. Ruby's usage of modules to support this behavior relates more closely to the concept of behavior rather than relationship. While multiple inheritance is a powerful tool\footnote{Though it comes at a steep price, since it increases complexity of implementation severely}, the presence of it in Python indicates a philosophy centered on inheritance rather than composition. The philosophy of Ruby, on the other hand, is to loosely couple shared groups of behavior with the desired classes - thus compositing the complete behavior of the class. Good example of where this is a more desired philosophy is when implementing a Data-Context-Interaction pattern.
\paragraph{}
On a larger scale this points to a difference in philosophy concerning the goals of the language, more specifically: \begin{quote}{"The principle of least surprise means principle of least my surprise. And it means the principle of least surprise after you learn Ruby very well.  - Yukihiro Matsumoto"}\cite{RubyPhil} 
\end{quote}
\paragraph{}
Multiple inheritance is known to be quite complex to use correctly, while providing very powerful tools for specializing instance-behavior. Composition, on the other hand, is quite simple to understand and use while not being as "strict" in the computer science sense of the word.

\subsection{Blocks vs. Functions}
Another difference in philosophy between Ruby and Python is the treatment of closures\footnote{A closure allows a function to execute outside its immediate lexical scope}. Where Python supports closures in two major ways - lambdas and unbound functions - Ruby provides a richer set of tools for using closures - procs, lambdas, blocks and method-objects\footnote{It can be argued that procs and lambdas are in essence the same thing, but that falls outside the scope of this text (and is plain wrong, see the arity-handling!)}. However, Python's lambdas are severely limited since they can only contain expressions and not statements, while Ruby allows any valid construct inside a closure. The difference this makes is apparent below: 
\lstinputlisting{block.rb}
while the corresponding pythonic way of doing a filter looks something like 
\lstinputlisting{filter.py}
\paragraph{}
Both languages support the notion of unbound functions, even though this is much simpler in Python than in Ruby (where it is actually quite complex once you need scope management), as in method objects not currently bound to an object and which can be bound at a later time to a suitable object. The main difference, however, is apparent when discussing blocks, and their nonexistence in Python. Python has an expressly stated goal from its most prolific core member that \begin{quote}{"Explicit is better than implicit." - Tim Peters}\cite{pythonzen} \end{quote}
\paragraph{}
This reflects in the choice of closure-support since the preferred way of handling them in Python - unbound methods - is a very explicit way since one decouples a bound method, making it an unbound method, passes it around (since functions are first-class objects in Python) and then binds them to a scope on execution. At all times do one act upon an Method-object. In Ruby, however, there's a notion of callable objects, that is - objects with respond to the method \emph{call}. These includes all the types mentioned above (and could thus also include user-defined objects implementing the same API). One can, for example, implicitly convert a method argument into a callable object using the following syntax: 
\lstinputlisting{ampersand.rb}
Note how the implicitly defined block is converted into an object at method-execution and is implicitly yielded to by the method body. This allows Ruby to use closures as dynamic callbacks for other methods, something that is possible in Python but require the use of external libraries to allow higher-order functions.
\paragraph{}
Ruby supports a very implicit style of scope management for both variables, and in order to support a more functionally oriented style of programming, while Python eschews implicitly declared scopes in lieu of making the process explicit and binding it to a single object and a construct.
\subsection{Built-in Functions vs. Global Object}
One major design difference between Ruby and Python is how to implement and make available basic and necessary functions and methods to a default scope, i.e. the scope where code is executed unless explicitly executed in another scope. This includes \emph{eval} and \emph{puts} in Ruby and \emph{file} and \emph{print} in Python. Ruby chooses to implement these as instance-methods on a global object\footnote{Much like the window-prototype in regular Javascript} while Python builds them into the interpreter. This has numerous implications, for example - adding new expressions in Ruby is a matter of opening up one of Object, Kernel or BaseObject (which are all present in the inheritance chain by default) and adding new instance methods - while adding new functions on that level in Python is not possible (they must be explicitly referenced). This reflects a difference in where the languages comes from. Python, which originally was intended as "[..] bridge the gap between the shell and C."\cite{pythondesign} whereas Ruby comes from "[...] concentrate on the fun and creative part of programming when they use Ruby."\cite{linuxdev}. Since built-in functions on an interpreter level encourages an expression-oriented style of coding (much like Lisp), something which might feel natural to someone used to C-style procedural coding, it's natural that Python should choose interpreter-level functions. Ruby, on the other hand, springing from a designer who explicitly wants to escape the then traditional style of coding has a design which encourages a completely different style of coding. 

\section{Question 2}
%Explain the term reflection, how it can be useful in software development and if there are any hidden pitfalls. Also provide one well explained and motivated example.
Reflection (and its sibling introspection) is a term denoting the ability of an executing program to look "into" itself at runtime and influence, view and/or modify its constructs, data and business logic while still executing. The exact application of reflection differs highly from language to language, both depending on design philosophy and on technical limitations. Generally speaking, reflection ranges from the ability of a program to list, for example, properties of an object - this is the case with among others C\# - to the ability to dynamically define new functions and methods, add and remove them to objects at will as well as rewriting the actual logic while executing - this is the case with among others Javascript, Ruby and Io. Dynamic method invocation is generally thought be a part of reflection as well - something which for example Java supports. 
\paragraph{}
Reflection is a natural part of metaprogramming, and as such can be very useful in a wide range of situations in software development. Reflection can be used to achieve highly dynamic scriptable programs, where key scripts can be changed during runtime or programs which change their behavior in response to external input or changes in the execution environment not possible to anticipate in its entirety at program creation. A very common use of reflection is for writing polymorphic serialization routines which can work with any object, instead of forcing the programmer to write custom serialization for every type created, which is the case with the XML-serializer in Ruby Standard Library for example. Other uses of reflection includes highly configurable genetic algorithms\cite{genetic} and high-level ORMs\footnote{Object/Relational Mapping} which adapt methods to the underlying data (for example DataMapper and ActiveRecord). 
\paragraph{}
What makes reflection useful in the cases above is the ability to make the program conform to input or the environment without having to anticipate all possible permutations of input. A good example of this is when building ORMs. The example below is using ActiveRecord, a Ruby ORM: 
\lstinputlisting{orm.rb}
The ORM reflects into the data fetched from the database, and dynamically adds methods to the User-class for the fields present, such as \emph{email} in the example. This allows for a natural style of coding while being very adaptable since adding a new field to the database automatically will result in the corresponding methods being available, and would be very hard and complex to implement without reflection. 
\paragraph{}
The biggest pitfalls with reflection is the inverse of its greatest strengths, that programs can adapt to input and the environment it executes in. Since a programmer has to define the boundaries for this adaption\footnote{With the exception of true generative programming, but that is at the moment more curiosity than a real issue in computer science.} and failure to cover the limitations properly will result in non-deterministic behavior and possibly bugs dependent on the external environment, which in turn are very hard to debug. This also makes it impossible to implement certain kinds of modifiable reflection in statically typed languages, since the compiler can't verify type checking or interface compliance at compile time. This is the reason for Java only implementing observing and invoking reflection, while for example Ruby allows for modifications to almost the entire context, program constructs and behavior\footnote{With the exception of class unloading which is currently impossible in Ruby}.
\paragraph{}
An example of reflection usage is the following Ruby code which adds a "macro" for resetting classes to blank slates, since Ruby lacks any class-unloading facility.
\lstinputlisting{gamengine.rb}
This code, when run in almost any Ruby environment will add the macro\footnote{This is not a true macro, but behaves macro-like.}-style to the environment. First, it uses dynamic invocation and slot modification to store a copy of the \emph{to\_s}-method which will not be removed. Then it uses reflection to fetch all instance methods of the class-instance passed, and removes them from the class unless they either begin with \emph{\_\_} or is \emph{object\_id} - both of which are either internal methods required by the Ruby runtime. Then it makes another pass using reflection to remove all class variables from the class and finally it uses more reflection to add a new version to \emph{to\_s} which prints the original version appended with a marker that it has been reset.

\section{Question 3}

%Ideally static typing guarantees that type errors do not occur at run-time. But what does dynamic typing guarantee? Is it really a sensible term? Motivate! (And explain what a type error is.)
%What would the effects be with respect to static typing if a method_missing hook (similar to that in Ruby or the doesNotUnderstand method in some Smalltalk dialects) was added to the Java language (or equivalent, like C++ or C#). [A method missing hook is a method invoked on an object o when o is sent a message that it does not understand.]

\section{Question 4}
%Motivate why it is (or isn’t) important for a scripting language to have literals for (lightweight) untyped (or generic/ parametrically polymorphic) simple data structures like lists, tuples and maps?
%(You should probably start out by defining what a scripting language is.)
There is no standard definition of what denotes a scripting language, however few themes are recurring and commonly shared between languages agreed upon to be scripting languages. Firstly, the lack of an explicit compiling and linking step. Contrary to compiled languages which require one or more compiling steps scripting languages are typically interpreted and executed on fly, passing the raw source code to the interpreter. Secondly, it is rare for programs written in a scripting language to be distributed in any other form than source, while compiled languages can be distributed as their binary, compiled products\footnote{Though the reverse is not strictly true as is very common for open-source packages to be distributed as source and compiled on the target platform.}. Other common traits of scripting languages is the lack of manually managed memory, usually relying on garbage collection with either reference counting (like Perl or Python) or a mark-and-sweep strategy (like Ruby) - though this is becoming present in non-scripting languages as well (most notable Obj-C with ARC\footnote{Automatic Reference Counting}). Thirdly - scripting languages tend to be used more for prototyping, rapid development, agile methods and similar development projects due to the flexible and less rigid nature of the code produced. This is by no means an absolute, but there's a strong tendency towards it. Since scripting languages lack a compiling/linking step, compile time type-checking is not seen in these kinds of languages\footnote{Though this becomes a little fuzzy since among others, the release of Diamondback Ruby which provides static typing to Ruby}.
\paragraph{}
For the purpose of this essay, a scripting language shall be defined as any \emph{language not required an explicit compilation and/or linking steps before executing}. Languages falling outside this definition shall also include languages compiling to bytecode (such as Java or ActionScript) before being distributed or run. Languages which are defined as scripting languages include, but are not limited to Ruby, Javascript, PHP, BASH, Perl and Python. 
\paragraph{}
Literals, which is a language construct for representing values and/or objects by implicitly creating them on execution, provide programmers with a "lighter" way of initializing objects. This can range from strings (which are commonly available as literals)  \lstinputlisting{string.m} to more complex datatypes: \lstinputlisting{hash.rb} to functions: \lstinputlisting{function.lua}
\paragraph{}
The presence of literals in a scripting language is important because of three major implications; shorter REPL\footnote{Read-Eval-Print-Loop}, higher abstraction-level and "\emph{mockability}".
\subsubsection{Shorter REPL}
As stated above, scripting languages are often employed for rapid development and prototyping where basic tenets programs are built on can rapidly change - thus the ability to rapidly change data structures or add new one becomes an important feature. The possibility to change add an array to a method, or change a map to an array provides quicker feedback on the written code, since the time between REPL-interations becomes shorter. This in turn frees the programmer from having to plan out the entire program before starting coding, thus increasing the feedback-loop between thinking, coding and testing. The benefits of this have been thoroughly explored in the TDD\footnote{Test-Driven Development} community\cite{testfirst}\cite{roitest} since the general consensus is that while test-driven development takes longer time, end result is of higher quality. Thus, shorter REPL leads to higher productivity, both when using TDD and when using other development strategies. 
\subsubsection{Higher Abstraction}
Consider the following example: 
\lstinputlisting{bignum.rb}
The code above uses number literals to create a variable \emph{number} in which it first stores a very large number\footnote{4611686018427387903 to be exact} and then prints its class. The class returned is Fixnum, which represents an integer value small enough to store in a machine word\footnote{A machine word minus 1 bit since 1 bit is used to mark reference vs. integer}. When the integer increases past the size possible to store in a Fixnum, the interpreter takes the literal and automatically uses the class Bignum instead (which uses multiple machine words to store integers, thus increasing the limit significantly). The programmer does not have to reflect on whether the variable in question can grow larger than given limits and can thus focus on writing code rather than managing that kind of special cases. 
\subsubsection{Mockability}
When developing a program in languages requiring explicitly typed data structures, the programmer often has to write significant parts of the code before it is possible to test the program flow, verify its usability or run it against test data to verify algorithms. Since the language requires the programmer to define exactly what type of objects will inhabit a given structure, those types has to be defined and be at least partially implemented before execution flow can move past the creation of the data structure in question. This prohibits testing of the entire logical flow before significant parts of the program is already written, and it limits the options of experimenting while analyzing the problem solved by the program. This also implies that the cost-of-change for a making a given decision can be very high, and have far-reaching implications. An untyped, literal-based creation of data structures allows for implementing the smallest part required for testing the purpose of the program, the business logic and usability - in turn lowering cost of development, increasing possibility of semantic correctness of the program and increasing developer creativity in problem solving.

\section{Question 5}
%Explain and relate the concepts weak/strong typing and dynamic/static typing to each other. Give examples of languages that fit into the four different cate- gories and explain and motivate your choices.
According to Craig\cite{craig} it is impossible to discuss programming languages without discussing their type systems. He relates this to the fact that 
\begin{quote}[...] the untyped $\lambda$-calculus has no consistent models, thus demonstrating that untyped languages produce unpredictable results [...]\end{quote}thus any language producing predictable results needs to have some kind of type system. 
Two of the major concept pairs in type theory are weak/strong typing and dynamic/static typing. These represent different approaches to adding a type system, and have very different implications for both language design and compiler/interpreter-design.
\subsubsection{Weak / Strong typing}
Weak typing implies that the type system supports implicit type conversion by the runtime environment, and that methods usually don't type-check parameters. Strong typing on the other hand implies that types might only interact with other types in clearly specified ways, such as one cannot subtract strings from integers or multiply arrays. Both of these concepts are strongly related to type safety - that is, the ability to guarantee that operations intended for one type does not inadvertently operate on any other type which might produce non-deterministic results. An example of weakly typed language is Javascript, which the example below indicates: 
\lstinputlisting{weak.js}
Note that the operation \emph{+} performs an implicit type conversion on the integer \emph{3}, casting it as String from Number, while the operation \emph{*} reverses the operation, instead converting the string \emph{"2"} into an instance of Number with value \emph{2} and producing a wildly different result. Unless the programmer knows the rules of this implicit conversion this can lead to unexpected results further on (as the example proves). One should note, however, that this behavior allows for using \emph{ad-hoc polymorphism} which can yield powerful levels of freedom in program design. This kind of operation would not be allowed in strongly typed language, such as Java, as shown in the example below: 
\lstinputlisting{strong.java} Note that the compiler doesn't even accept compilation, much less execution of the program, since the behavior of \emph{*} is not defined for arguments of type String and Float. This prevents the program yielding the kind of unexpected results showcased in the Javascript example above. 
\subsubsection{Dynamic / Static typing}
The concepts of dynamic and static typing relate to how/when/if type checking is done. Type checking is the process of validating that the operations performed are compatible with the types it is performed on. This can either be done at compile time (static type) or at runtime (dynamic type)\footnote{Though C++ makes an interesting example where it can done at both times through the type information available at runtime.}. An example of a statically typed language is Objective-C, as shown here: 
\lstinputlisting{static_type.m} This example will not compile, the compiler will throw an error stating that \emph{Invalid operands to binary expression ('int' and 'char *')} and cancel the compilation. Change the type of \emph{string[]} to an \emph{int} would let the compilation finish. Thus, type checking is performed at compile time, making Objective-C a statically typed language.
Language with dynamic typing performs the type check at runtime, and will throw a runtime error if an operation is applied to incompatible types. This allows for dynamic creation of types, for example - creating new classes in runtime in Ruby, which is a dynamically typed language. The example below displays this: 
\lstinputlisting{dynamic_type.rb}
Note that no type-checking is performed until the operation is actually performed (which fails)\footnote{For the sake of clarity in the example, the rescue-clause required here has been removed.}, then re-evaluated the next time 
at which point the type \emph{Ninja} supports division (albeit with a quite weird implementation) and a proper result is returned.
This makes Ruby a dynamically typed language, although this particular style of dynamic typing is often referred to as \emph{Duck Typing} since it's not really the type being checked, it's the conformity of the object to the requested interface (in this example, support of division operations). The term implies that the actual identity of the object is irrelevant, and that the relevant issue is whether it can perform the requested operation, as stated by Alex Mertelli\cite{mertelli}, credited with inventing the term in its current usage: \begin{quote}In other words, don't check whether it IS-a duck: check whether it QUACKS-like-a duck, WALKS-like-a duck, etc, etc, depending on exactly what subset of duck-like behaviour you need to play your language-games with.\end{quote}


\bibliographystyle{abbrv}
\small\raggedright
\bibliography{bib_file}


\end{document} 