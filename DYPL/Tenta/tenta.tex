\documentclass[a4paper,10pt]{article}

\usepackage[latin1]{inputenc}
% \usepackage[swedish]{babel}
\usepackage[english]{babel}

\usepackage{xspace,graphicx}
\usepackage{url}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{textcomp}

% The three lines below gives paragraphs with a distance between
% instead of indented first line.
\frenchspacing
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus .5ex minus .5ex}

\title{Test - DYPL}
\author{Daniel Sundstrom \\ 
  \texttt{daniel@sykewarrior.com}}
\date{\today}

\begin{document}
\maketitle
%\tableofcontents

\section{Question 1}
%What are the major differences in terms of design philosophy between Ruby and Python? Are there any similarities? In what ways are these design philosophies visible in the languages? Give examples, discuss, explain them and motivate your choices.
There are some major differences in the philosophy underpinning the design and the choices made for each language. In short, these differences can be described as; \emph{Multiple inheritance vs. Mixins}, \emph{Blocks vs. Functions} and \emph{Built-in Functions vs. Global Object}. These differences will be explored in depth below.

\subsection{Multiple inheritance vs. Mixins}
One of the major differences in design between Ruby and Python is how the language handles class-based behavior modification, both at runtime and at write time. Ruby favors a module-based approach, where specific methods\footnote{Which, in Ruby, of course includes attributes since they are implemented as methods} are grouped together in named modules, which in turn are included in the desired classes to provide the behavior. Modules can be included both as class methods and as instance methods, depending on the keyword used for inclusion. This is illustrated in the example below. 
\lstinputlisting{modules.rb}
As the example shows, this allows for composing the aggregate behavior for a class into separate, re-usable components (since a module can be included in any number of classes). Python, on the other hand, supports the same behavior through a limited form of multiple inheritance\footnote{Resolution is depth-first, left-to-right} as shown below: 
\lstinputlisting{inheritance.py}
As clearly shown in the examples above, both of these styles support the same effect - but point to interesting differences in design philosophy. 
One of the basic tenets of OOP\footnote{Object-Oriented Programming} is its suitability and ability to map and represent real-world systems and relationships, and this is also one of basic foundation of object-oriented modeling as taught and discussed today\cite{good_ideas}\cite{real_world_modelling}. The relationship of RangedNinja in regard to Ninja is more of superset-subset rather than a formal relationship. Ruby's usage of modules to support this behavior relates more closely to the concept of behavior rather than relationship. While multiple inheritance is a powerful tool\footnote{Though it comes at a steep price, since it increases complexity of implementation severely}, the presence of it in Python indicates a philosophy centered on inheritance rather than composition. The philosophy of Ruby, on the other hand, is to loosely couple shared groups of behavior with the desired classes - thus compositing the complete behavior of the class. Good example of where this is a more desired philosophy is when implementing a Data-Context-Interaction pattern.
\paragraph{}
On a larger scale this points to a difference in philosophy concerning the goals of the language, more specifically: \begin{quote}{"The principle of least surprise means principle of least my surprise. And it means the principle of least surprise after you learn Ruby very well.  - Yukihiro Matsumoto"}\cite{RubyPhil} 
\end{quote}
\paragraph{}
Multiple inheritance is known to be quite complex to use correctly, while providing very powerful tools for specializing instance-behavior. Composition, on the other hand, is quite simple to understand and use while not being as "strict" in the computer science sense of the word.

\subsection{Blocks vs. Functions}
Another difference in philosophy between Ruby and Python is the treatment of closures\footnote{A closure allows a function to execute outside its immediate lexical scope}. Where Python supports closures in two major ways - lambdas and unbound functions - Ruby provides a richer set of tools for using closures - procs, lambdas, blocks and method-objects\footnote{It can be argued that procs and lambdas are in essence the same thing, but that falls outside the scope of this text (and is plain wrong, see the arity-handling!)}. However, Python's lambdas are severely limited since they can only contain expressions and not statements, while Ruby allows any valid construct inside a closure. The difference this makes is apparent below: 
\lstinputlisting{block.rb}
while the corresponding pythonic way of doing a filter looks something like 
\lstinputlisting{filter.py}
\paragraph{}
Both languages support the notion of unbound functions, even though this is much simpler in Python than in Ruby (where it is actually quite complex once you need scope management), as in method objects not currently bound to an object and which can be bound at a later time to a suitable object. The main difference, however, is apparent when discussing blocks, and their nonexistence in Python. Python has an expressly stated goal from its most prolific core member that \begin{quote}{"Explicit is better than implicit." - Tim Peters}\cite{pythonzen} \end{quote}
\paragraph{}
This reflects in the choice of closure-support since the preferred way of handling them in Python - unbound methods - is a very explicit way since one decouples a bound method, making it an unbound method, passes it around (since functions are first-class objects in Python) and then binds them to a scope on execution. At all times do one act upon an Method-object. In Ruby, however, there's a notion of callable objects, that is - objects with respond to the method \emph{call}. These includes all the types mentioned above (and could thus also include user-defined objects implementing the same API). One can, for example, implicitly convert a method argument into a callable object using the following syntax: 
\lstinputlisting{ampersand.rb}
Note how the implicitly defined block is converted into an object at method-execution and is implicitly yielded to by the method body. This allows Ruby to use closures as dynamic callbacks for other methods, something that is possible in Python but require the use of external libraries to allow higher-order functions.
\paragraph{}
Ruby supports a very implicit style of scope management for both variables, and in order to support a more functionally oriented style of programming, while Python eschews implicitly declared scopes in lieu of making the process explicit and binding it to a single object and a construct.
\subsection{Built-in Functions vs. Global Object}
One major design difference between Ruby and Python is how to implement and make available basic and necessary functions and methods to a default scope, i.e. the scope where code is executed unless explicitly executed in another scope. This includes \emph{eval} and \emph{puts} in Ruby and \emph{file} and \emph{print} in Python. Ruby chooses to implement these as instance-methods on a global object\footnote{Much like the window-prototype in regular Javascript} while Python builds them into the interpreter. This has numerous implications, for example - adding new expressions in Ruby is a matter of opening up one of Object, Kernel or BaseObject (which are all present in the inheritance chain by default) and adding new instance methods - while adding new functions on that level in Python is not possible (they must be explicitly referenced). This reflects a difference in where the languages comes from. Python, which originally was intended as "[..] bridge the gap between the shell and C."\cite{pythondesign} whereas Ruby comes from "[...] concentrate on the fun and creative part of programming when they use Ruby."\cite{linuxdev}. Since built-in functions on an interpreter level encourages an expression-oriented style of coding (much like Lisp), something which might feel natural to someone used to C-style procedural coding, it's natural that Python should choose interpreter-level functions. Ruby, on the other hand, springing from a designer who explicitly wants to escape the then traditional style of coding has a design which encourages a completely different style of coding. 

\section{Question 2}
%Explain the term reflection, how it can be useful in software development and if there are any hidden pitfalls. Also provide one well explained and motivated example.
Reflection (and its sibling introspection) is a term denoting the ability of an executing program to look "into" itself at runtime and influence, view and/or modify its constructs, data and business logic while still executing. The exact application of reflection differs highly from language to language, both depending on design philosophy and on technical limitations. Generally speaking, reflection ranges from the ability of a program to list, for example, properties of an object - this is the case with among others C\# - to the ability to dynamically define new functions and methods, add and remove them to objects at will as well as rewriting the actual logic while executing - this is the case with among others Javascript, Ruby and Io. Dynamic method invocation is generally thought be a part of reflection as well - something which for example Java supports. 
\paragraph{}
Reflection is a natural part of metaprogramming, and as such can be very useful in a wide range of situations in software development. Reflection can be used to achieve highly dynamic scriptable programs, where key scripts can be changed during runtime or programs which change their behavior in response to external input or changes in the execution environment not possible to anticipate in its entirety at program creation. A very common use of reflection is for writing polymorphic serialization routines which can work with any object, instead of forcing the programmer to write custom serialization for every type created, which is the case with the XML-serializer in Ruby Standard Library for example. Other uses of reflection includes highly configurable genetic algorithms\cite{genetic} and high-level ORMs\footnote{Object/Relational Mapping} which adapt methods to the underlying data (for example DataMapper and ActiveRecord). 
\paragraph{}
What makes reflection useful in the cases above is the ability to make the program conform to input or the environment without having to anticipate all possible permutations of input. A good example of this is when building ORMs. The example below is using ActiveRecord, a Ruby ORM: 
\lstinputlisting{orm.rb}
The ORM reflects into the data fetched from the database, and dynamically adds methods to the User-class for the fields present, such as \emph{email} in the example. This allows for a natural style of coding while being very adaptable since adding a new field to the database automatically will result in the corresponding methods being available, and would be very hard and complex to implement without reflection. 
\paragraph{}
The biggest pitfalls with reflection is the inverse of its greatest strengths, that programs can adapt to input and the environment it executes in. Since a programmer has to define the boundaries for this adaption\footnote{With the exception of true generative programming, but that is at the moment more curiosity than a real issue in computer science.} and failure to cover the limitations properly will result in non-deterministic behavior and possibly bugs dependent on the external environment, which in turn are very hard to debug. This also makes it impossible to implement certain kinds of modifiable reflection in statically typed languages, since the compiler can't verify type checking or interface compliance at compile time. This is the reason for Java only implementing observing and invoking reflection, while for example Ruby allows for modifications to almost the entire context, program constructs and behavior\footnote{With the exception of class unloading which is currently impossible in Ruby}.
\paragraph{}
An example of reflection usage is the following Ruby code which adds a "macro" for resetting classes to blank slates, since Ruby lacks any class-unloading facility.
\lstinputlisting{gamengine.rb}
This code, when run in almost any Ruby environment will add the macro\footnote{This is not a true macro, but behaves macro-like.}-style to the environment. First, it uses dynamic invocation and slot modification to store a copy of the \emph{to\_s}-method which will not be removed. Then it uses reflection to fetch all instance methods of the class-instance passed, and removes them from the class unless they either begin with \emph{\_\_} or is \emph{object\_id} - both of which are either internal methods required by the Ruby runtime. Then it makes another pass using reflection to remove all class variables from the class and finally it uses more reflection to add a new version to \emph{to\_s} which prints the original version appended with a marker that it has been reset.

\section{Question 3}

%Ideally static typing guarantees that type errors do not occur at run-time. But what does dynamic typing guarantee? Is it really a sensible term? Motivate! (And explain what a type error is.)%What would the effects be with respect to static typing if a method_missing hook (similar to that in Ruby or the doesNotUnderstand method in some Smalltalk dialects) was added to the Java language (or equivalent, like C++ or C#). [A method missing hook is a method invoked on an object o when o is sent a message that it does not understand.]

\section{Question 4}

%Motivate why it is (or isn’t) important for a scripting language to have literals for (lightweight) untyped (or generic/ parametrically polymorphic) simple data structures like lists, tuples and maps?%(You should probably start out by defining what a scripting language is.)

\section{Question 5}

%Explain and relate the concepts weak/strong typing and dynamic/static typing to each other. Give examples of languages that fit into the four different cate- gories and explain and motivate your choices.

\bibliographystyle{abbrv}
\small\raggedright
\bibliography{bib_file}


\end{document} 